//==========================================================================
vector<shared_ptr<ftSurface> >
RegularizeFace::holeToHoleSplit(vector<vector<ftEdge*> >& half_holes,
				vector<hole_info>& holes, 
				vector<pair<int,int> >& hole_idx,
				vector<double>& seg_lengths
				vector<pair<Point, Point> >& seg_endpt)
//==========================================================================
{
  vector<shared_ptr<CurveOnSurface> > trim_seg;
  shared_ptr<BoundedSurface> bd_sf;
  shared_ptr<ParamSurface> surf = face_->surface();
  for (size_t kh=0; kh<hole_idx.size(); ++kh)
    {
      int idx1 = hole_idx[kh].first;
      int idx2 = hole_idx[kh].second;
      double len = seg_lengths[kh];

      // For each hole, collect all corner and non-corner vertices
      vector<shared_ptr<Vertex> > corner1;
      vector<shared_ptr<Vertex> > corner2;
      vector<shared_ptr<Vertex> > non_corner1;
      vector<shared_ptr<Vertex> > non_corner2;
      vector<ftEdge*> edges1;
      vector<ftEdge*> edges2;
      int nmb_holes = face_->nmbBoundaryLoops() - 1;
      if (idx1 < nmb_holes)
	edges1 = face_->getAllEdgePtrs(idx1+1);
      else
	edges1 = half_holes[idx1-nmb_holes];

      Path::classifyCorners(edges1,  bend_,
			    corner1, non_corner1);

      if (idx2 < nmb_holes)
	edges2 = face_->getAllEdgePtrs(idx2+1);
      else
	edges2 = half_holes[idx2-nmb_holes];

      Path::classifyCorners(edges2, bend_, 
			    corner2, non_corner2);

      // Sort possible combinations of vertices according to the distance
      // between them and whether or not one or both vertices are corners
      double fac = 2.0;  // Penalty factor for not being a corner
      vector<pair<shared_ptr<Vertex>, shared_ptr<Vertex> > > vx_pair;
      vector<double> vx_dist;

#ifdef DEBUG_REG
      std::ofstream of0("split_segments.g2");
#endif

      size_t ki, kj;
      for (ki=0; ki<corner1.size(); ++ki)
	{
	  for (kj=0; kj<corner2.size(); ++kj)
	    {
	      double dist = corner1[ki]->getDist(corner2[kj]);
	      vx_pair.push_back(make_pair(corner1[ki], corner2[kj]));
	      vx_dist.push_back(dist);
	    }
	  for (kj=0; kj<non_corner2.size(); ++kj)
	    {
	      double dist = corner1[ki]->getDist(non_corner2[kj]);
	      vx_pair.push_back(make_pair(corner1[ki], non_corner2[kj]));
	      vx_dist.push_back(fac*dist);
	    }
	}

      for (ki=0; ki<non_corner1.size(); ++ki)
	{
	  for (kj=0; kj<corner2.size(); ++kj)
	    {
	      double dist = non_corner1[ki]->getDist(corner2[kj]);
	      vx_pair.push_back(make_pair(non_corner1[ki], corner2[kj]));
	      vx_dist.push_back(fac*dist);
	    }
	  for (kj=0; kj<non_corner2.size(); ++kj)
	    {
	      double dist = non_corner1[ki]->getDist(non_corner2[kj]);
	      vx_pair.push_back(make_pair(non_corner1[ki], non_corner2[kj]));
	      vx_dist.push_back(2.0*fac*dist);
	    }
	}
     
      // Sort
      for (ki=0; ki<vx_pair.size(); ++ki)
	for (kj=ki+1; kj<vx_pair.size(); ++kj)
	  if (vx_dist[kj] < vx_dist[ki])
	    {
	      std::swap(vx_dist[ki], vx_dist[kj]);
	      std::swap(vx_pair[ki], vx_pair[kj]);
	    }

      // For each candidate pair until two candidates are selected, 
      // check if a splitting curve between the vertices is legal
      for (ki=0; ki<vx_pair.size(); ++ki)
	{
	  Point parval1 = vx_pair[ki].first->getFacePar(face_.get());
	  Point parval2 = vx_pair[ki].second->getFacePar(face_.get());
	  vector<shared_ptr<CurveOnSurface> > local_seg 
	    = BoundedUtils::getTrimCrvsParam(surf, parval1,
					     parval2, epsge_,
					     bd_sf);

	  // Remove segments not connected with the original vertices
	  RegularizeUtils::checkTrimSeg3(local_seg, parval1, parval2, epsge_);

	  if (local_seg.size() == 1)
	    {
	      bool modified = adjustTrimSeg(local_seg[0], vx_pair[ki].first, 
					    edges1, vx_pair[ki].second, 
					    edges2, len);
#ifdef DEBUG_REG
	      shared_ptr<ParamCurve> cv = local_seg[0]->spaceCurve();
	      cv->writeStandardHeader(of0);
	      cv->write(of0);
#endif
	  
	      trim_seg.push_back(local_seg[0]);

	      if (!modified)
		{
		  // Remove candidates involving the current vertices
		  for (kj=ki+1; kj<vx_pair.size(); )
		    {
		      if (vx_pair[kj].first.get() == vx_pair[ki].first.get() ||
			  vx_pair[kj].second.get() == vx_pair[ki].second.get())
			{
			  vx_pair.erase(vx_pair.begin()+kj);
			  vx_dist.erase(vx_dist.begin()+kj);
			}
		      else
			++kj;
		    }
		  for (kj=0; kj<corner1.size(); )
		    {
		      if (vx_pair[ki].first.get() == corner1[kj].get())
			corner1.erase(corner1.begin()+kj);
		      else
			++kj;
		    }
		  for (kj=0; kj<non_corner1.size(); )
		    {
		      if (vx_pair[ki].first.get() == non_corner1[kj].get())
			non_corner1.erase(non_corner1.begin()+kj);
		      else
			++kj;
		    }
		  for (kj=0; kj<corner2.size(); )
		    {
		      if (vx_pair[ki].second.get() == corner2[kj].get())
			corner2.erase(corner2.begin()+kj);
		      else
			++kj;
		    }
		  for (kj=0; kj<non_corner2.size(); )
		    {
		      if (vx_pair[ki].second.get() == non_corner2[kj].get())
			non_corner2.erase(non_corner2.begin()+kj);
		      else
			++kj;
		    }
		}
	    }
	  if (trim_seg.size() == 2)
	    break; 
	}

      if (trim_seg.size() < 2)
	{
	  // For each vertex on one loop, find the closest point on the
	  // other loop
	  vector<pair<Point, Point > > par_pair;
	  vector<double> par_dist;

	  corner1.insert(corner1.end(), non_corner1.begin(), non_corner1.end());
	  for (ki=0; ki<corner1.size(); ++ki)
	    {
	      int clo_ind;
	      double clo_par, clo_dist;
	      Point clo_pt;
	      Point pnt = corner1[ki]->getVertexPoint();
	      Path::closestPoint(edges2, pnt, clo_ind, 
				 clo_par, clo_pt, clo_dist);
	      Point parval1 = corner1[ki]->getFacePar(face_.get());
	      Point parval2 = edges2[clo_ind]->faceParameter(clo_par);
	      par_pair.push_back(make_pair(parval1, parval2));
	      par_dist.push_back(clo_dist);
	    }

	  corner2.insert(corner2.end(), non_corner2.begin(), non_corner2.end());
	  for (ki=0; ki<corner2.size(); ++ki)
	    {
	      int clo_ind;
	      double clo_par, clo_dist;
	      Point clo_pt;
	      Point pnt = corner2[ki]->getVertexPoint();
	      Path::closestPoint(edges1, pnt, clo_ind, 
				 clo_par, clo_pt, clo_dist);
	      Point parval1 = corner2[ki]->getFacePar(face_.get());
	      Point parval2 = edges1[clo_ind]->faceParameter(clo_par);
	      par_pair.push_back(make_pair(parval1, parval2));
	      par_dist.push_back(clo_dist);
	    }

	  // Sort
	  for (ki=0; ki<par_pair.size(); ++ki)
	    for (kj=ki+1; kj<par_pair.size(); ++kj)
	      if (par_dist[kj] < par_dist[ki])
		{
		  std::swap(par_dist[ki], par_dist[kj]);
		  std::swap(par_pair[ki], par_pair[kj]);
		}

	  // For each candidate pair until two candidates are selected, 
	  // check if a splitting curve between the vertices is legal
	  vector<shared_ptr<CurveOnSurface> > trim_seg;
	  shared_ptr<BoundedSurface> bd_sf;
	  shared_ptr<ParamSurface> surf = face_->surface();
	  for (ki=0; ki<par_pair.size(); ++ki)
	    {
	      Point parval1 = par_pair[ki].first;
	      Point parval2 = par_pair[ki].second;
	      vector<shared_ptr<CurveOnSurface> > local_seg 
		= BoundedUtils::getTrimCrvsParam(surf, parval1,
						 parval2, epsge_,
						 bd_sf);

	      // Remove segments not connected with the original vertices
	      RegularizeUtils::checkTrimSeg3(local_seg, parval1, parval2, epsge_);

	      if (local_seg.size() == 1)
		{
#ifdef DEBUG_REG
		  shared_ptr<ParamCurve> cv = local_seg[0]->spaceCurve();
		  cv->writeStandardHeader(of0);
		  cv->write(of0);
#endif
		  trim_seg.push_back(local_seg[0]);
		}
	      if (trim_seg.size() == 2)
		break; 
	    }
	}
    }
  
  vector<shared_ptr<ftSurface> > faces;
  if (trim_seg.size() < 2)
    return faces;   // Trimming curves will not split
      
  // Divide surface
  vector<shared_ptr<BoundedSurface> > sub_sfs =
    BoundedUtils::splitWithTrimSegments(bd_sf, trim_seg, epsge_);

#ifdef DEBUG_REG
  std::ofstream of("split_surf.g2");
  for (size_t kr=0; kr<sub_sfs.size(); ++kr)
    {
      sub_sfs[kr]->writeStandardHeader(of);
      sub_sfs[kr]->write(of);
    }
#endif
      
  // Fetch info about vertices not belonging to the corners of the
  // initial face
  vector<shared_ptr<Vertex> > non_corner = 
    face_->getNonCornerVertices(bend_);
  removeInsignificantVertices(non_corner);

  faces = RegularizeUtils::createFaces(sub_sfs, face_, epsge_, tol2_,
				       angtol_, non_corner);
 
  return faces;
}

